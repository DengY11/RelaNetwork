# 缓存层 (pkg/cache)

本包负责提供缓存功能，旨在提高读取性能、避免缓存雪崩，并采用最终一致性模型。

## 核心策略

考虑到本服务的具体场景，每次get社交网络都会读取大量数据，并且用户对缓存一致性的要求并不高，因此基于性能、可用性和一致性要求，我们选择以下策略组合：

1.  **核心模式：读旁路缓存 (Read-Aside / Cache-Aside Pattern)**
    *   **读取流程**: 应用优先查询缓存，缓存未命中时查询数据库，查询成功后将数据写入缓存再返回。
    *   **适用场景**: 读多写少，接受最终一致性。

2.  **避免缓存雪崩/击穿**: 
    *   **必须**: **设置随机化的过期时间 (TTL Jitter)**：为缓存项设置基础 TTL 的同时，增加一个小的随机时间偏移，打散过期时间点。
    *   **推荐 (热点数据)**: **逻辑过期/预取**：在缓存值中存储逻辑过期时间，允许在物理 TTL 到期前异步刷新缓存或通过分布式锁控制单请求刷新，其他请求返回旧数据。
    *   **基础设施**: **缓存服务高可用**: 依赖 Redis Sentinel 或 Cluster 等机制保证缓存服务自身的可用性。
    *   **防御措施**: **服务降级/限流**: 当缓存异常时，具备限流访问数据库或暂时关闭缓存的能力。

3.  **写入操作策略**: 
    *   **模式**: **先更新/删除数据库，再删除缓存 (Write Invalidation)**：确保数据库操作成功后，使缓存失效。下次读取时会重新加载新数据。
    *   **选择删除而非更新缓存**: 逻辑简单，避免写库成功但更新缓存失败导致的数据不一致，符合最终一致性要求。

4.  **防止缓存穿透**: 
    *   **缓存空值**: 当数据库查询确认数据不存在时，缓存一个空值或特殊标识符（设置**较短 TTL**），避免对不存在数据的重复数据库查询。

## 实现说明

*   缓存的具体实现（如 Redis）应在 `Set` 操作中内置 TTL Jitter 逻辑。
*   逻辑过期/预取和分布式锁机制根据具体热点数据的访问模式按需实现。
*   空值缓存逻辑应在数据库查询未命中后执行。
*   缓存接口 (`interface.go`) 定义核心的 Get/Set/Delete 操作，符合读旁路和写失效模式。
*   错误处理：定义标准的 `ErrNotFound` 以区分缓存中确实不存在和获取缓存时发生的其他错误。 